# 二、C++ 类
```table-of-contents
```
## 2.1 类的初探

类的主要目的是将**数据和与数据相关的操作**封装在一起。

C++ 类的基本结构通常包含：
- **数据成员（Attributes）**：定义类的属性。
- **成员函数（Methods）**：定义类的行为。
- **构造函数和析构函数**：特殊的成员函数。构造函数在创建对象时自动调用，用于初始化对象。析构函数在对象销毁时调用，用于执行清理操作。
- **访问修饰符**：用于控制对类成员的访问权限。
- **继承**：允许一个类继承另一个类的特性。

## 2.2 权限初识

> 类中成员默认为私有。

类中访问修饰符权限：

|   访问权限    | 类内部 | 同一个类的对象 | 派生类 (子类) | 类外部 |
| :-------: | :-: | :-----: | :------: | :-: |
|  public   |  ✅  |    ✅    |    ✅     |  ✅  |
|  private  |  ✅  |    ❎    |    ❎     |  ❎  |
| protected |  ✅  |    ❎    |    ✅     |  ❎  |

使用权限是一种关键的封装手段，旨在控制对类成员的访问。

| ​**分类**​ | ​**条目**​ |                ​**详细描述**​                |
| :------: | :------: | :--------------------------------------: |
| ​**好处**​ |   封装性    |   通过隐藏类的内部实现（私有和受保护成员），提高了代码的安全性和健壮性。    |
|          | 接口与实现的分离 | 公开接口（公开成员）与私有实现分离，有助于用户仅关注于如何使用类而不是如何实现。 |
|          |   易于维护   |      修改类的内部实现不会影响使用该类的代码，从而降低了维护成本。      |
|          |  控制读写访问  |         通过设置访问权限，可以精确控制类成员的读写访问。         |
|          |  继承的灵活性  |    `protected` 成员在派生类中是可访问的，使得继承更加灵活。    |
| ​**缺点**​ |  增加复杂性   |       过度使用或不当使用权限可能导致代码结构复杂，难以理解。        |
|          |   测试难度   |      私有成员的测试比公共成员更困难，因为它们不能从类的外部访问。      |
|          |  灵活性降低   |       过于严格的封装可能限制了某些有效的用法，降低了灵活性。        |
|          | 可能导致紧耦合  |     过多依赖 `friend` 类或函数可能导致类之间的耦合过紧。      |

> 在 C++ 中，双冒号 `::` 称为 "作用域解析运算符"（Scope Resolution Operator）。它用于指定一个成员（如函数或变量）属于特定的类或命名空间。例如，在类的外部定义成员函数时， `::` 用于指明该函数属于哪个类。
>  
> 在 C++中，一个类包含另一个类的对象称为组合（Composition）。这是一种常见的设计模式，用于表示一个类是由另一个类的对象组成的。这种关系通常表示一种"拥有"（"has-a"）的关系。

如何使用类中类成员？
- 当类成员是指针类型，则需要先通过 `new xxx` 的方式创建对象，再通过 `.` 或 `->` 运算符方式。
- 当类成员是对象，则直接通过 `.` 或 `->` 运算符方式。

## 2.3 引用

### 2.3.1 引用和指针

常量指针和指针常量区别：

核心区别在于 `const` 关键字修饰的对象不同。

**常量指针（Pointer to Constant）​**
- ​**定义**：指针指向的对象是常量，不能通过指针修改其值，但指针本身可以指向其他对象。
- ​**语法**： `const T* ptr;` 或 `T const* ptr;`  
	- （ `const` 在 `*` 左侧，强调指向对象的不可变性）。
- ​**特性**：
    - ​**指向内容不可变**：通过指针无法修改目标对象的值
    - ​**指针可变**：指针可以重新指向其他地址
- ​**适用场景**：需要保护数据不被意外修改时（如函数参数传递只读数据）
- **示例**

```c++
int a = 10, b = 20;
const int* ptr = &a;  // ptr 是常量指针
// *ptr = 30;         // 错误：不能通过 ptr 修改 a
ptr = &b;             // 正确：ptr 可指向其他对象
```

**指针常量（Constant Pointer）​**
- ​**定义**：指针本身是常量，初始化后不能再指向其他对象，但可以通过指针修改目标对象的值。
- ​**语法**： `T* const ptr;`  
    （ `const` 在 `*` 右侧，强调指针本身的不可变性）。
- ​**特性**：
    - ​**指针不可变**：初始化后指针的指向固定
    - ​**指向内容可变**：可通过指针修改目标对象的值
- ​**适用场景**：需要固定指针指向（如数组名作为指针常量）
- ​**示例**：

```cpp
int a = 10, b = 20;
int* const ptr = &a;  // ptr 是指针常量
*ptr = 30;            // 正确：可以修改 a 的值
// ptr = &b;          // 错误：ptr 不能指向其他对象
```

> 在 C++ 中，**引用（ `&` ）的底层实现本质是指针常量（ `int* const` ）​**，而非常量指针（ `const int*` ）。

**引用的核心特性**
1. ​**必须初始化**：引用在声明时必须绑定到一个合法对象，类似于指针常量必须初始化。
2. ​**不可为空**：引用不能绑定到 `nullptr` ，而指针可以为空。
3. ​**语法简化**：引用无需解引用（ `*` ）即可直接操作目标对象，隐藏了指针的复杂性。
4. ​**类型安全**：引用有严格的类型检查，而指针可能因类型转换导致未定义行为。

**引用总结**
- ​**引用是语法糖**：其底层实现为指针常量（ `int* const` ），但语法上屏蔽了指针操作，提供更直观的别名机制。
- ​**与指针常量的区别**：引用在编译时强制类型检查和不可为空，增强了安全性；指针常量仍需手动管理解引用和空指针问题。
- ​**选择依据**：优先使用引用以提高代码可读性和安全性；需要动态绑定或空值时使用指针。

### 2.3.2 把引用作为返回值

**引用特殊用法**：

函数作为左值：

```c++
double values[] = { 1, 2, 3, 4, 5 };  
double &setValue(const int &i) {  
    double &ref = values[i];  
    return ref;  
}
int main(){
	setValue(3) = 120.1; /// 函数被当作左值  
	cout << values[3] << endl;	
}
```

>  **引用不能超出作用域**，所以返回一个对局部变量的引用是不合法的。但是可以返回一个对静态变量的引用。

## 2.4 重载

在同一个作用域内，可以声明几个功能类似的同名函数，这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。

