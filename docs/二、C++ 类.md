# 二、C++ 类
```table-of-contents
```
## 2.1 类的初探

类的主要目的是将**数据和与数据相关的操作**封装在一起。

C++ 类的基本结构通常包含：
- **数据成员（Attributes）**：定义类的属性。
- **成员函数（Methods）**：定义类的行为。
- **构造函数和析构函数**：特殊的成员函数。构造函数在创建对象时自动调用，用于初始化对象。析构函数在对象销毁时调用，用于执行清理操作。
- **访问修饰符**：用于控制对类成员的访问权限。
- **继承**：允许一个类继承另一个类的特性。

## 2.2 权限初识

> 类中成员默认为私有。

类中访问修饰符权限：

|   访问权限    | 类内部 | 同一个类的对象 | 派生类 (子类) | 类外部 |
| :-------: | :-: | :-----: | :------: | :-: |
|  public   |  ✅  |    ✅    |    ✅     |  ✅  |
|  private  |  ✅  |    ❎    |    ❎     |  ❎  |
| protected |  ✅  |    ❎    |    ✅     |  ❎  |

使用权限是一种关键的封装手段，旨在控制对类成员的访问。

| ​**分类**​ | ​**条目**​ |                ​**详细描述**​                |
| :------: | :------: | :--------------------------------------: |
| ​**好处**​ |   封装性    |   通过隐藏类的内部实现（私有和受保护成员），提高了代码的安全性和健壮性。    |
|          | 接口与实现的分离 | 公开接口（公开成员）与私有实现分离，有助于用户仅关注于如何使用类而不是如何实现。 |
|          |   易于维护   |      修改类的内部实现不会影响使用该类的代码，从而降低了维护成本。      |
|          |  控制读写访问  |         通过设置访问权限，可以精确控制类成员的读写访问。         |
|          |  继承的灵活性  |    `protected` 成员在派生类中是可访问的，使得继承更加灵活。    |
| ​**缺点**​ |  增加复杂性   |       过度使用或不当使用权限可能导致代码结构复杂，难以理解。        |
|          |   测试难度   |      私有成员的测试比公共成员更困难，因为它们不能从类的外部访问。      |
|          |  灵活性降低   |       过于严格的封装可能限制了某些有效的用法，降低了灵活性。        |
|          | 可能导致紧耦合  |     过多依赖 `friend` 类或函数可能导致类之间的耦合过紧。      |

> 在 C++ 中，双冒号 `::` 称为 "作用域解析运算符"（Scope Resolution Operator）。它用于指定一个成员（如函数或变量）属于特定的类或命名空间。例如，在类的外部定义成员函数时， `::` 用于指明该函数属于哪个类。
>  
> 在 C++中，一个类包含另一个类的对象称为组合（Composition）。这是一种常见的设计模式，用于表示一个类是由另一个类的对象组成的。这种关系通常表示一种"拥有"（"has-a"）的关系。

如何使用类中类成员？
- 当类成员是指针类型，则需要先通过 `new xxx` 的方式创建对象，再通过 `.` 或 `->` 运算符方式。
- 当类成员是对象，则直接通过 `.` 或 `->` 运算符方式。

## 2.3 引用

### 2.3.1 引用和指针

常量指针和指针常量区别：

核心区别在于 `const` 关键字修饰的对象不同。

**常量指针（Pointer to Constant）​**
- ​**定义**：指针指向的对象是常量，不能通过指针修改其值，但指针本身可以指向其他对象。
- ​**语法**： `const T* ptr;` 或 `T const* ptr;`  
	- （ `const` 在 `*` 左侧，强调指向对象的不可变性）。
- ​**特性**：
    - ​**指向内容不可变**：通过指针无法修改目标对象的值
    - ​**指针可变**：指针可以重新指向其他地址
- ​**适用场景**：需要保护数据不被意外修改时（如函数参数传递只读数据）
- **示例**

```c++
int a = 10, b = 20;
const int* ptr = &a;  // ptr 是常量指针
// *ptr = 30;         // 错误：不能通过 ptr 修改 a
ptr = &b;             // 正确：ptr 可指向其他对象
```

**指针常量（Constant Pointer）​**
- ​**定义**：指针本身是常量，初始化后不能再指向其他对象，但可以通过指针修改目标对象的值。
- ​**语法**： `T* const ptr;`  
    （ `const` 在 `*` 右侧，强调指针本身的不可变性）。
- ​**特性**：
    - ​**指针不可变**：初始化后指针的指向固定
    - ​**指向内容可变**：可通过指针修改目标对象的值
- ​**适用场景**：需要固定指针指向（如数组名作为指针常量）
- ​**示例**：

```cpp
int a = 10, b = 20;
int* const ptr = &a;  // ptr 是指针常量
*ptr = 30;            // 正确：可以修改 a 的值
// ptr = &b;          // 错误：ptr 不能指向其他对象
```

> 在 C++ 中，**引用（ `&` ）的底层实现本质是指针常量（ `int* const` ）​**，而非常量指针（ `const int*` ）。

**引用的核心特性**
1. ​**必须初始化**：引用在声明时必须绑定到一个合法对象，类似于指针常量必须初始化。
2. ​**不可为空**：引用不能绑定到 `nullptr` ，而指针可以为空。
3. ​**语法简化**：引用无需解引用（ `*` ）即可直接操作目标对象，隐藏了指针的复杂性。
4. ​**类型安全**：引用有严格的类型检查，而指针可能因类型转换导致未定义行为。

**引用总结**
- ​**引用是语法糖**：其底层实现为指针常量（ `int* const` ），但语法上屏蔽了指针操作，提供更直观的别名机制。
- ​**与指针常量的区别**：引用在编译时强制类型检查和不可为空，增强了安全性；指针常量仍需手动管理解引用和空指针问题。
- ​**选择依据**：优先使用引用以提高代码可读性和安全性；需要动态绑定或空值时使用指针。

### 2.3.2 把引用作为返回值

**引用特殊用法**：

函数作为左值：

```c++
double values[] = { 1, 2, 3, 4, 5 };  
double &setValue(const int &i) {  
    double &ref = values[i];  
    return ref;  
}
int main(){
	setValue(3) = 120.1; /// 函数被当作左值  
	cout << values[3] << endl;	
}
```

>  **引用不能超出作用域**，所以返回一个对局部变量的引用是不合法的。但是可以返回一个对静态变量的引用。

## 2.4 重载

### 2.4.1 函数重载

在同一个作用域内，可以声明几个功能类似的同名函数，这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。

### 2.4.2 运算符重载

```c++
class Point {
public:
    int _x;
    int _y;
    /// const 表明该重载函数不会修改调用它的 Point 对象。
    /// 它只是读取对象的 x 和 y 成员，并返回一个新的 Point 对象。
    /// 确保某些函数不会意外改变对象的状态，也同时使得这个函数可以在常量对象上被调用。
    Point operator+(const Point &point_temp) const;
};

Point Point::operator+(const Point &point_temp) const {
    Point point_temp_new{};
    point_temp_new._x = this->_x + point_temp._x;
    point_temp_new._y = this->_y + point_temp._y;
    return point_temp_new;
}

int main(){
	Point p1{};
	p1._x = 1;
	p1._y = 2;
	
	Point p2{};
	p2._x = 3;
	p2._y = 4;
	
	Point p3 = p1 + p2;
	
	std::cout << "p3 x is: " << p3._x << ", p3 y is: " << p3._y << std::endl;
	
	return 0;
}
```

**重载要点**
- **一致性**：重载运算符应与其原示意图和常见用法保持一致。
- **复杂性**：过度使用运算符重载可能导致代码难以理解和维护。应确保它们的使用直观且合理。

## 2.5 构造函数

用于为某些成员变量设置初始值。

>  当自定义构造函数时，会删除默认的无参构造函数。

### 2.5.1 初始化列表

在 C++中，使用初始化列表来初始化类的字段是一种高效的初始化方式，尤其在构造函数中。初始化列表直接在对象的构造过程中初始化成员变量，而不是先创建成员变量后再赋值。这对于提高性能尤其重要，特别是在涉及到复杂对象或引用和常量成员的情况下。

初始化列表的优点包括： 
1. **效率**：对于非基本类型的对象，使用初始化列表比在构造函数体内赋值更高效，因为它避免了先默认构造然后再赋值的额外开销。 
2. **必要性**：对于**引用类型和常量类型的成员变量，必须使用初始化列表**，因为这些类型的成员变量在构造函数体内不能被赋值。 
3. **顺序**：成员变量的初始化顺序是按照它们在类中声明的顺序，而不是初始化列表中的顺序。

> 使用初始化列表是 C++中推荐的初始化类成员变量的方式，因为它提供了更好的性能和灵活性。

### 2.5.2 this 关键字

`this` 关键字是**指向调用对象的指针**。在成员函数内部使用，用于引用调用该函数的对象。

```c++
class Car {  
public:  
    std::pmr::string _brand;  
    int _year{ 0 };  
    void display() const { std::cout << "品牌：" << _brand << ", 年份：" << _year << std::endl; }  
    
	///！
    Car &setYear(const int &year) {  
        this->_year = year;  
        return *this; /// 返回调用对象的指针  
    }  
    ///!
};

int main(){
	/// 链式调用  
	car3.setYear(2024).display();
}
```

### 2.5.3 new 和 delete 关键字

`new` 关键字用于动态分配内存。与 `delete` 关键字配对使用，避免内存泄露。

**注意事项**
- **异常安全**：如果 `new` 分配内存失败，它会抛出 `std:: bad_alloc` 异常（除非使用 `nothrow` 版本）。
- **内存泄露**：忘记释放使用 `new` 分配的内存会导致内存泄露。
- **匹配使用** `delete` **和** `delete[]` ：为避免未定义行为，使用 `new` 分配的单个对象应该使用 `delete` 释放，使用 `new[]` 分配的数组应该使用 `delete[]` 释放。

## 2.6 析构函数

在对象生命周期结束时被自动调用，用于执行对象销毁前的清理工作。析构函数特别重要，尤其是在涉及动态分配的资源（如内存、文件句柄、网络连接等）的情况下。

> 当对象的生命周期结束时（例如，一个局部对象的作用域结束，或者使用 delete 删除一个动态分配的对象），析构函数会被自动调用。
> 
> 析构函数在管理资源方面非常重要。没有正确实现析构函数，可能导致资源泄露或其他问题。在基于RAII （资源获取即初始化）原则的C++编程实践中，确保资源在对象析构时被适当释放是非常关键的。当使用智能指针和其他自动资源管理技术时，可以减少显式编写析构函数的需要，但了解析构函数的工作原理仍然很重要。


**析构函数核心特性**

|      要点       |                               描述                               |
| :-----------: | :------------------------------------------------------------: |
|  ​**定义和用途**​  |               析构函数在对象生命周期结束时自动调用，用于清理对象可能持有的资源。                |
|   ​**语法**​    |   析构函数名称由波浪线（ `~` ）后跟类名构成，例如 `MyClass` 的析构函数为 `~MyClass()` 。   |
|  ​**资源管理**​   |              用于释放对象在生命周期中分配的资源，如动态内存、文件句柄、网络连接等。               |
| ​**自动调用机制**​  |             当对象离开其作用域或通过 `delete` 删除时，将自动调用其析构函数。              |
| ​**防止资源泄露**​  |              正确实现析构函数对防止资源泄露至关重要，特别是在涉及动态资源分配的情况。              |
|  ​**虚析构函数**​  | 如果类作为基类设计，应有一个虚析构函数（ `virtual ~BaseClass()` ），以确保正确调用派生类的析构函数。 |
| ​**析构函数与异常**​ |                   析构函数不应抛出异常，如果可能抛出，应在函数内捕获。                   |

**删除的析构函数与构造函数规则**

|       要点       |                                          描述                                          |
| :------------: | :----------------------------------------------------------------------------------: |
| ​**删除的析构函数**​  |                  可以通过将析构函数声明为删除（ `~MyClass() = delete;` ）来禁止删除某类对象。                  |
| ​**与构造函数的关系**​ |                              每个类只能有一个析构函数，不可重载，与构造函数相比。                              |
| ​**规则三则/五则**​  | 如果类需要自定义析构函数、拷贝构造函数或拷贝赋值运算符，可能也需要自定义另外两个（规则三则）。<br>在 C++11 后还包括移动构造函数和移动赋值运算符（规则五则）。 |
## 2.7 静态成员

静态成员包括静态成员变量和静态成员函数。

**静态成员变量**
1. **定义**：是类的所有对象共享的变量。和普通变量相比，无论创建多少个类的实例，静态成员变量只有一份拷贝。
2. **初始化**：需要在类外进行初始化，通常在类的实现文件中。
3. **访问**：可以通过类名直接访问，不需要创建类的对象，也可以通过类的对象访问。
4. **用途**：常用于存储类级别的信息（如，计数类的实例数量）或全局数据需要被类的所有实例共享。

**静态成员函数**
1. **定义**：不依赖于类的实例而被调用的函数。其不能访问类的非静态成员变量和非静态成员函数。
2. **访问**：类似静态成员变量。
3. **用途**：实现与具体对象无关的功能，或访问静态成员变量。

**存在意义**
1. **共享数据**：允许对象间共享数据。
2. **节省内存**
3. **独立于对象的功能实现**：对于实现工具函数或管理类级别状态很有用。

## 2.8 继承

继承的主要目的是实现代码重用，以及建立一种类型之间的层次关系。

### 2.8.1 权限对继承的影响

C++ 中，继承分为公有（public）、保护（protected）和私有（private），这决定了基类成员在派生类中的访问权限。

**基类成员访问权限**

|  基类成员类型   | public 继承 | protected 继承 | private 继承 |
| :-------: | :-------: | :----------: | :--------: |
|  public   |  public   |  protected   |  private   |
| protected | protected |  protected   |  private   |
|  private  |   不可访问    |     不可访问     |    不可访问    |

继承等级降级，通常是那个范围小，就用那个。

### 2.8.2 基类构造函数

派生类可以通过构造函数的初始化列表来调用基类的构造函数。这是派生类对象时初始化基类部分的**标准做法**。

```c++
class Vehicle { /* 交通工具：车，抽象的概念 */
    double _price{ 0 };
    Vehicle(double price) :_price(price) {}
};

/// 派生类，子类
class Roadster : public Vehicle { /* 跑车，但比父类感觉上范围缩小了 */
	std::string _brand;
    Roadster(double price,std::string brand ) : Vehicle(price), _brand(brand) {}
};
```

先调用基类的构造函数，再调用派生类的构造函数。

### 2.8.3 虚函数

`virtual` 和 `override` 关键字用于支持多态，尤其是在设计类继承和方法重写的情况下。

**virtual** 
- **使用场景**：一般在基类声明。
- **目的**：允许派生类重写该函数，实现多态。
- **行为**：当通过基类的指针或引用调用一个虚函数时，调用的是对象实际类型的函数版本。

> 功能有点虚😃，表示在后面告诉编译器（或程序员👨‍💻）这里的功能不完善，需要在派生类中重写。

```c++
class Base {
public:
	virtual void func() {
		std::cout << "Function in Base." << std::endl;
	}
}
```

**override**
- **使用场景**：在派生类中重写虚函数。
- **目的**：明确指示函数意图重写基类的虚函数。
- **行为**：确保派生类的函数确实重写了基类中的一个虚函数，如果没有匹配到虚函数，编译器报错。

```c++
class Derived : public Base {
public:
	void func() override {
		std::cout << "Function in Derived." << std::endl;
	}
}
```

**注意**
1. 如果类中有虚函数，通常应该将析构函数也声明为虚析构函数。

> 正确使用 `virtual` 和 `override` 关键字有助于清晰地表达程序员的意图，并利用编译器检查来避免常见的错误，如签名不匹配导致的非预期的函数重写。

### 2.8.4 多重继承

多重继承是一种允许一个类同时继承多个基类的特性。这意味着派生类可以继承多个基类的属性和方法。多重继承增加了语言的灵活性，但同时也引入了额外的复杂性，特别是当多个基类具有相同的成员时。

> 如果不同的基类有相同名称的成员，则必须明确指出所引用的是哪个基类成员。

多重继承是 C++的一个强大特性，但**应谨慎使用**。合理地应用多重继承可以使代码更加灵活和强大，但不当的使用可能导致设计上的问题和维护困难。

虽然多重继承提供了很大的灵活性，但过度使用可能导致代码难以理解和维护。在一些情况下，使用组合或接口（纯虚类）可能是更好的设计选择。
### 2.8.5 虚继承

**菱形继承问题**：如果两个基类继承自同一个更高层的基类，这可能导致派生类中存在两份基类的副本，称为菱形继承（或钻石继承）问题。这可以通过虚继承来解决。

> 虚继承是C++中一种特殊的继承方式，主要用来解决多重继承中的菱形继承问题。在菱形继承结构中，一个类继承自两个具有共同基类的类时，会导致共同基类的成员在派生类中存在两份拷贝，这不仅会导致资源浪费，还可能引起数据不一致的问题。虚继承通过确保共同基类的单一实例存在于继承层次中，来解决这一问题。

```c++
class Base {
public:
	int _data;
	Base(int data) {
		this->_data = data;
	}
}

class Derived1 : virtual public Base {
public:
	Derived1(int data) : Base(data) {}
};

class Derived2 : virtual public Base {
public:
	Derived2(int data) : Base(data) {}
};

class FinalDerived : public Derived1, public Derived2 {
	/// 解决菱形问题
public:
	Derived2(int data) : Base(data), Derived1(data), Derived2(data) {}
};
```

## 2.9 多态

